const { Client, GatewayIntentBits } = require('discord.js');
const axios = require('axios');
const cheerio = require('cheerio');
const pdf = require('pdf-parse');
const cron = require('node-cron');

// ç’°å¢ƒè®Šæ•¸è¨­å®š
const DISCORD_TOKEN = process.env.DISCORD_TOKEN;
const CHANNEL_ID = process.env.CHANNEL_ID;
const TARGET_URL = 'https://www.blessing.org.tw/%E4%B8%AD%E5%A4%AE%E5%BB%9A%E6%88%BF';

// å‰µå»ºDiscordå®¢æˆ¶ç«¯
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent
    ]
});

// ä¸‹è¼‰PDFçš„å‡½æ•¸
async function downloadPDF(pdfUrl) {
    try {
        const response = await axios({
            method: 'GET',
            url: pdfUrl,
            responseType: 'arraybuffer',
            timeout: 30000,
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
        });
        return Buffer.from(response.data);
    } catch (error) {
        console.error('ä¸‹è¼‰PDFå¤±æ•—:', error.message);
        throw error;
    }
}

// å¾ç¶²ç«™ç²å–PDFé€£çµ
async function getPDFLink() {
    try {
        const response = await axios.get(TARGET_URL, {
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
        });
        
        const $ = cheerio.load(response.data);
        
        // å°‹æ‰¾PDFé€£çµï¼Œå¯èƒ½éœ€è¦æ ¹æ“šå¯¦éš›ç¶²ç«™çµæ§‹èª¿æ•´
        let pdfLink = null;
        
        // æ–¹æ³•1: å°‹æ‰¾hrefåŒ…å«.pdfçš„é€£çµ
        $('a[href*=".pdf"]').each((index, element) => {
            const href = $(element).attr('href');
            if (href) {
                pdfLink = href.startsWith('http') ? href : new URL(href, TARGET_URL).href;
                return false; // æ‰¾åˆ°ç¬¬ä¸€å€‹å°±åœæ­¢
            }
        });
        
        // æ–¹æ³•2: å¦‚æœæ²’æ‰¾åˆ°ï¼Œå˜—è©¦å°‹æ‰¾å¯èƒ½çš„PDFé€£çµ
        if (!pdfLink) {
            $('a').each((index, element) => {
                const href = $(element).attr('href');
                const text = $(element).text().toLowerCase();
                if (href && (text.includes('pdf') || text.includes('èœå–®') || text.includes('é¤é»'))) {
                    pdfLink = href.startsWith('http') ? href : new URL(href, TARGET_URL).href;
                    return false;
                }
            });
        }
        
        return pdfLink;
    } catch (error) {
        console.error('ç²å–PDFé€£çµå¤±æ•—:', error.message);
        throw error;
    }
}

// å¾PDFæå–æ–‡å­—
async function extractTextFromPDF(pdfBuffer) {
    try {
        const data = await pdf(pdfBuffer);
        return data.text;
    } catch (error) {
        console.error('PDFæ–‡å­—æå–å¤±æ•—:', error.message);
        throw error;
    }
}

// å°‡é•·æ–‡æœ¬åˆ†å‰²æˆå¤šå€‹è¨Šæ¯
function splitMessage(text, maxLength = 1900) {
    const messages = [];
    let currentMessage = '';
    
    const lines = text.split('\n');
    
    for (const line of lines) {
        if (currentMessage.length + line.length + 1 > maxLength) {
            if (currentMessage.trim()) {
                messages.push(currentMessage.trim());
            }
            currentMessage = line;
        } else {
            currentMessage += (currentMessage ? '\n' : '') + line;
        }
    }
    
    if (currentMessage.trim()) {
        messages.push(currentMessage.trim());
    }
    
    return messages;
}

// ä¸»è¦åŠŸèƒ½å‡½æ•¸
async function fetchAndPostPDF() {
    try {
        console.log('é–‹å§‹åŸ·è¡ŒPDFä¸‹è¼‰èˆ‡ç™¼å¸ƒä»»å‹™...');
        
        const channel = await client.channels.fetch(CHANNEL_ID);
        if (!channel) {
            console.error('æ‰¾ä¸åˆ°æŒ‡å®šçš„é »é“');
            return;
        }
        
        // ç²å–PDFé€£çµ
        const pdfLink = await getPDFLink();
        if (!pdfLink) {
            await channel.send('âŒ ç„¡æ³•æ‰¾åˆ°PDFé€£çµ');
            return;
        }
        
        console.log('æ‰¾åˆ°PDFé€£çµ:', pdfLink);
        
        // ä¸‹è¼‰PDF
        const pdfBuffer = await downloadPDF(pdfLink);
        
        // æå–æ–‡å­—
        const text = await extractTextFromPDF(pdfBuffer);
        
        if (!text.trim()) {
            await channel.send('âŒ PDFæ–‡å­—æå–å¤±æ•—æˆ–å…§å®¹ç‚ºç©º');
            return;
        }
        
        // ç™¼é€æ¨™é¡Œè¨Šæ¯
        const now = new Date();
        const dateString = now.toLocaleDateString('zh-TW', {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            weekday: 'long'
        });
        
        await channel.send(`ğŸ“„ **${dateString} ä¸­å¤®å»šæˆ¿èœå–®**\n${pdfLink}`);
        
        // åˆ†å‰²ä¸¦ç™¼é€æ–‡å­—å…§å®¹
        const messages = splitMessage(text);
        
        for (let i = 0; i < messages.length; i++) {
            await channel.send(`\`\`\`\n${messages[i]}\n\`\`\``);
            
            // é¿å…è§¸ç™¼Discordçš„é€Ÿç‡é™åˆ¶
            if (i < messages.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }
        
        console.log('PDFå…§å®¹ç™¼å¸ƒå®Œæˆ');
        
    } catch (error) {
        console.error('åŸ·è¡Œä»»å‹™æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
        
        try {
            const channel = await client.channels.fetch(CHANNEL_ID);
            await channel.send(`âŒ åŸ·è¡Œä»»å‹™æ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message}`);
        } catch (channelError) {
            console.error('ç™¼é€éŒ¯èª¤è¨Šæ¯å¤±æ•—:', channelError);
        }
    }
}

// Discordæ©Ÿå™¨äººäº‹ä»¶
client.once('ready', () => {
    console.log(`æ©Ÿå™¨äººå·²ç™»å…¥: ${client.user.tag}`);
    
    // è¨­å®šæ¯é€±äº”ä¸­åˆ12é»åŸ·è¡Œ
    // åˆ† æ™‚ æ—¥ æœˆ é€±
    cron.schedule('0 12 * * 5', fetchAndPostPDF, {
        timezone: 'Asia/Taipei'
    });
    
    console.log('å·²è¨­å®šå®šæ™‚ä»»å‹™: æ¯é€±äº”ä¸­åˆ12é»');
});

// æ·»åŠ æ‰‹å‹•è§¸ç™¼æŒ‡ä»¤ï¼ˆå¯é¸ï¼‰
client.on('messageCreate', async (message) => {
    if (message.author.bot) return;
    
    if (message.content === '!pdf' && message.channelId === CHANNEL_ID) {
        await message.reply('é–‹å§‹æ‰‹å‹•åŸ·è¡ŒPDFä¸‹è¼‰ä»»å‹™...');
        await fetchAndPostPDF();
    }
});

// éŒ¯èª¤è™•ç†
client.on('error', (error) => {
    console.error('Discordå®¢æˆ¶ç«¯éŒ¯èª¤:', error);
});

process.on('unhandledRejection', (error) => {
    console.error('æœªè™•ç†çš„Promiseæ‹’çµ•:', error);
});

// ç™»å…¥Discord
client.login(DISCORD_TOKEN);
